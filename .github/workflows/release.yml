name: Build and Release APK

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      tag:
        description: 'Tag version (e.g., v1.0.0)'
        required: true
        type: string
      release_notes:
        description: 'Release notes (leave empty to use commit message)'
        required: false
        type: string
        default: ''
permissions:
  contents: write
jobs:
  build-android-linux:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.ref }}
      
    - name: Extract version from tag
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          TAG="${{ github.event.inputs.tag }}"
        else
          TAG=${GITHUB_REF#refs/tags/}
        fi
        VERSION=${TAG#v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
        # Check if tag contains beta
        if [[ "$TAG" == *"beta"* ]]; then
          echo "is_prerelease=true" >> $GITHUB_OUTPUT
        else
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Update pubspec.yaml version
      run: |
        sed -i "s/^version:.*/version: ${{ steps.version.outputs.version }}+${{ github.run_number }}/" pubspec.yaml
        
    - name: Setup Java
      uses: actions/setup-java@v4
      with:
        distribution: 'zulu'
        java-version: '17'
        
    # Flutter SDK ÁºìÂ≠ò
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version-file: .flutter-version
        channel: 'stable'
        cache: true  # ÂêØÁî® Flutter SDK ÁºìÂ≠ò
        cache-key: 'flutter-:os:-:channel:-:version:-:arch:-:hash:'
        cache-path: '${{ runner.tool_cache }}/flutter'

    
    # Gradle ÁºìÂ≠ò
    - name: Cache Gradle
      uses: actions/cache@v4
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          android/.gradle
          android/app/.gradle
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
        
    - name: Get dependencies
      run: flutter pub get
      
    - name: Decode keystore
      run: |
        echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 -d > android/app/keystore.jks
      
    - name: Create key.properties
      run: |
        echo "storePassword=${{ secrets.STORE_PASSWORD }}" > android/key.properties
        echo "keyPassword=${{ secrets.KEY_PASSWORD }}" >> android/key.properties
        echo "keyAlias=${{ secrets.KEY_ALIAS }}" >> android/key.properties
        echo "storeFile=keystore.jks" >> android/key.properties
      
    - name: Build APK - ARM64 (v8a)
      run: |
        flutter build apk --release --target-platform android-arm64
        mv build/app/outputs/flutter-apk/app-release.apk build/app/outputs/flutter-apk/pt_mate-${{ steps.version.outputs.version }}-arm64-v8a.apk
          
    - name: Upload Android artifacts
      uses: actions/upload-artifact@v4
      with:
        name: android-artifacts
        path: |
          build/app/outputs/flutter-apk/pt_mate-${{ steps.version.outputs.version }}-arm64-v8a.apk
        retention-days: 1
        
    # Áõ¥Êé•Âú®AndroidÊûÑÂª∫ÂêéÊ∑ªÂä†LinuxÊûÑÂª∫Ê≠•È™§
    - name: Install Linux dependencies
      run: |
        sudo apt-get update -y
        sudo apt-get install -y ninja-build libgtk-3-dev libblkid-dev libsecret-1-dev file libfuse2 lld
    
    # CMake ÁºìÂ≠ò
    - name: Cache CMake
      uses: actions/cache@v4
      with:
        path: |
          build/linux
          ~/.cmake
        key: ${{ runner.os }}-cmake-${{ hashFiles('**/CMakeLists.txt') }}
        restore-keys: |
          ${{ runner.os }}-cmake-
        
    - name: Build Linux
      run: flutter build linux --release
      
    # AppImageTool ÁºìÂ≠ò
    - name: Cache AppImageTool
      uses: actions/cache@v4
      with:
        path: appimagetool-x86_64.AppImage
        key: ${{ runner.os }}-appimagetool-continuous
        restore-keys: |
          ${{ runner.os }}-appimagetool-
    
    - name: Download AppImageTool
      run: |
        if [ ! -f appimagetool-x86_64.AppImage ]; then
          wget -O appimagetool-x86_64.AppImage https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage
        fi
        chmod +x appimagetool-x86_64.AppImage
        
    - name: Create AppImage
      run: |
        # ÂàõÂª∫AppDirÁªìÊûÑ
        mkdir -p AppDir/usr/bin
        mkdir -p AppDir/usr/lib
        mkdir -p AppDir/usr/share/applications
        mkdir -p AppDir/usr/share/icons/hicolor/256x256/apps
        
        # Â§çÂà∂Â∫îÁî®Êñá‰ª∂
        cp -r build/linux/x64/release/bundle/* AppDir/usr/bin/
        
        # ÂàõÂª∫Ê°åÈù¢Êñá‰ª∂
        cat > AppDir/usr/share/applications/pt_mate.desktop << EOF
        [Desktop Entry]
        Type=Application
        Name=PT Mate
        Comment=PT‰º¥‰æ£
        Exec=pt_mate
        Icon=pt_mate
        Categories=Network;
        Terminal=false
        EOF
        
        cp mt.png AppDir/usr/share/icons/hicolor/256x256/apps/pt_mate.png

        # ÂàõÂª∫AppRunËÑöÊú¨
        cat > AppDir/AppRun << 'EOF'
        #!/bin/bash
        HERE="$(dirname "$(readlink -f "${0}")")"
        export LD_LIBRARY_PATH="${HERE}/usr/lib:${LD_LIBRARY_PATH}"
        exec "${HERE}/usr/bin/pt_mate" "$@"
        EOF
        chmod +x AppDir/AppRun
        
        # Â§çÂà∂Ê°åÈù¢Êñá‰ª∂Âà∞Ê†πÁõÆÂΩï
        cp AppDir/usr/share/applications/pt_mate.desktop AppDir/
        
        # Â§çÂà∂ÂõæÊ†áÂà∞Ê†πÁõÆÂΩï
        cp AppDir/usr/share/icons/hicolor/256x256/apps/pt_mate.png AppDir/
        
        # ÂàõÂª∫AppImage
        ./appimagetool-x86_64.AppImage AppDir pt_mate-${{ steps.version.outputs.version }}-linux-x64.AppImage
        
    - name: Upload Linux artifact
      uses: actions/upload-artifact@v4
      with:
        name: linux-artifact
        path: pt_mate-${{ steps.version.outputs.version }}-linux-x64.AppImage
        retention-days: 1

  build-windows:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.ref }}
        
    - name: Extract version from tag
      id: version
      shell: bash
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          TAG="${{ github.event.inputs.tag }}"
        else
          TAG=${GITHUB_REF#refs/tags/}
        fi
        VERSION=${TAG#v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
    # Flutter SDK ÁºìÂ≠ò
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version-file: .flutter-version
        channel: 'stable'
        cache: true  # ÂêØÁî® Flutter SDK ÁºìÂ≠ò
        cache-key: 'flutter-:os:-:channel:-:version:-:arch:-:hash:'
        cache-path: '${{ runner.tool_cache }}/flutter'
        
    # Visual Studio ÁºìÂ≠ò
    - name: Cache Visual Studio
      uses: actions/cache@v4
      with:
        path: |
          C:\Users\runneradmin\AppData\Local\Microsoft\VisualStudio
          build/windows
        key: ${{ runner.os }}-vs-${{ hashFiles('**/CMakeLists.txt') }}
        restore-keys: |
          ${{ runner.os }}-vs-
    
    - name: Get dependencies
      run: flutter pub get
      
    - name: Build Windows
      run: flutter build windows --release
    
    - name: Install Inno Setup
      run: |
        # Ê£ÄÊü•ÊòØÂê¶Â∑≤ÂÆâË£ÖÔºåÈÅøÂÖçÈáçÂ§çÂÆâË£Ö
        if (-not (Test-Path "C:\Program Files (x86)\Inno Setup 6\ISCC.exe")) {
          choco install innosetup -y
        } else {
          Write-Host "Inno Setup already installed"
        }
        
    - name: Download Chinese language file
      run: |
        $languagesDir = "C:\Program Files (x86)\Inno Setup 6\Languages"
        if (-not (Test-Path "$languagesDir\ChineseSimplified.isl")) {
          Invoke-WebRequest -Uri "https://raw.githubusercontent.com/jrsoftware/issrc/main/Files/Languages/Unofficial/ChineseSimplified.isl" -OutFile "$languagesDir\ChineseSimplified.isl"
        }
        
    - name: Compile Inno Setup installer
      run: |
        iscc /DMyAppVersion="${{ steps.version.outputs.version }}" windows/inno_setup.iss
        
    - name: Upload Windows artifact
      uses: actions/upload-artifact@v4
      with:
        name: windows-artifact
        path: windows/Output/pt_mate-${{ steps.version.outputs.version }}-windows-x64.exe
        retention-days: 1

  build-ios-and-macos:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.ref }}
        
    - name: Extract version from tag
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          TAG="${{ github.event.inputs.tag }}"
        else
          TAG=${GITHUB_REF#refs/tags/}
        fi
        VERSION=${TAG#v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
    # Flutter SDK ÁºìÂ≠ò
    - name: Setup Flutter
      uses: subosito/flutter-action@v2
      with:
        flutter-version-file: .flutter-version
        channel: 'stable'
        cache: true  # ÂêØÁî® Flutter SDK ÁºìÂ≠ò
        cache-key: 'flutter-:os:-:channel:-:version:-:arch:'
        cache-path: '${{ runner.tool_cache }}/flutter'
    
    
    # CocoaPods ÁºìÂ≠ò
    - name: Cache CocoaPods
      uses: actions/cache@v4
      with:
        path: |
          ios/Pods
          ~/.cocoapods
        key: ${{ runner.os }}-pods-${{ hashFiles('**/Podfile.lock') }}
        restore-keys: |
          ${{ runner.os }}-pods-
    
    # Xcode ÁºìÂ≠ò
    - name: Cache Xcode DerivedData
      uses: actions/cache@v4
      with:
        path: ~/Library/Developer/Xcode/DerivedData
        key: ${{ runner.os }}-xcode-${{ hashFiles('**/project.pbxproj') }}
        restore-keys: |
          ${{ runner.os }}-xcode-
        
    - name: Get dependencies
      run: flutter pub get
      
    - name: Build unsigned IPA
      run: |
        # Build iOS app bundle
        flutter build ios --release --no-codesign
        
        # Create build directory
        mkdir -p ios/build
        
        # Create IPA manually from app bundle
        mkdir -p Payload
        cp -r build/ios/iphoneos/Runner.app Payload/
        zip -r ios/build/pt_mate-${{ steps.version.outputs.version }}-unsigned.ipa Payload/
        rm -rf Payload
        
    - name: Create xcarchive
      run: |
        cd ios
        xcodebuild -workspace Runner.xcworkspace \
          -scheme Runner \
          -configuration Release \
          -destination generic/platform=iOS \
          -archivePath build/Runner.xcarchive \
          archive \
          CODE_SIGNING_ALLOWED=NO
        
    - name: Create xcarchive zip
      run: |
        cd ios/build
        zip -r pt_mate-${{ steps.version.outputs.version }}.xcarchive.zip Runner.xcarchive
        
    - name: Build macOS
      run: flutter build macos --release
      
    - name: Ad-hoc sign macOS app
      run: |
        codesign --force --deep --sign - \
          --entitlements "macos/Runner/Release.entitlements" \
          "build/macos/Build/Products/Release/pt_mate.app"
      
    - name: Create macOS DMG
      run: |
        hdiutil create -volname "PT Mate ${{ steps.version.outputs.version }}" \
          -srcfolder "build/macos/Build/Products/Release/pt_mate.app" \
          -ov -format UDZO \
          "build/macos/Build/Products/Release/pt_mate-${{ steps.version.outputs.version }}-macos-x64.dmg"

    - name: Zip macOS app
      run: |
        cd build/macos/Build/Products/Release
        zip -r pt_mate-${{ steps.version.outputs.version }}-macos-x64.app.zip pt_mate.app
        cd -
          
    - name: Upload iOS and macOS artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ios-macos-artifacts
        path: |
          ios/build/pt_mate-${{ steps.version.outputs.version }}-unsigned.ipa
          ios/build/pt_mate-${{ steps.version.outputs.version }}.xcarchive.zip
          build/macos/Build/Products/Release/pt_mate-${{ steps.version.outputs.version }}-macos-x64.dmg
          build/macos/Build/Products/Release/pt_mate-${{ steps.version.outputs.version }}-macos-x64.app.zip
        retention-days: 1

  create-release:
    runs-on: ubuntu-latest
    needs: [build-android-linux, build-windows, build-ios-and-macos]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.ref }}
        
    - name: Extract version from tag
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          TAG="${{ github.event.inputs.tag }}"
        else
          TAG=${GITHUB_REF#refs/tags/}
        fi
        VERSION=${TAG#v}
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        
        # Check if tag contains beta
        if [[ "$TAG" == *"beta"* ]]; then
          echo "is_prerelease=true" >> $GITHUB_OUTPUT
        else
          echo "is_prerelease=false" >> $GITHUB_OUTPUT
        fi
        
    - name: Get release message
      id: commit_message
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ -n "${{ github.event.inputs.release_notes }}" ]; then
          RELEASE_MSG="${{ github.event.inputs.release_notes }}"
        else
          # Get the latest commit message (full message including body)
          RELEASE_MSG=$(git log -1 --pretty=format:"%B")
        fi
        
        # Save to output using multiline format
        echo "message<<EOF" >> $GITHUB_OUTPUT
        echo "$RELEASE_MSG" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT
        
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      
    - name: Create Release and Upload All Artifacts
      uses: softprops/action-gh-release@v2
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.version.outputs.tag }}
        name: Release ${{ steps.version.outputs.tag }}
        body: |
          ## Changes in this release
          ${{ steps.commit_message.outputs.message }}
          
          ## üì± Android APK Downloads
          
          - **ARM64 APK** (arm64-v8a): For modern 64-bit devices
          
          ## üíª Desktop Downloads
          
          - **Windows x64**: Windows installer for 64-bit systems
          - **Linux x64**: Linux AppImage for 64-bit systems (portable, no installation required)
          - **macOS x64**: macOS DMG image for 64-bit systems
          - **macOS x64 (app)**: Zipped .app file for manual installation or use on systems where DMG is not preferred

          ## üçé iOS Downloads
          
          - **Unsigned IPA**: For sideloading with tools like AltStore, Sideloadly, etc.
          - **Xcode Archive**: For developers to re-sign and distribute
          
        draft: false
        prerelease: ${{ steps.version.outputs.is_prerelease }}
        files: |
          android-artifacts/pt_mate-${{ steps.version.outputs.version }}-arm64-v8a.apk
          windows-artifact/pt_mate-${{ steps.version.outputs.version }}-windows-x64.exe
          linux-artifact/pt_mate-${{ steps.version.outputs.version }}-linux-x64.AppImage
          ios-macos-artifacts/ios/build/pt_mate-${{ steps.version.outputs.version }}-unsigned.ipa
          ios-macos-artifacts/ios/build/pt_mate-${{ steps.version.outputs.version }}.xcarchive.zip
          ios-macos-artifacts/build/macos/Build/Products/Release/pt_mate-${{ steps.version.outputs.version }}-macos-x64.dmg
          ios-macos-artifacts/build/macos/Build/Products/Release/pt_mate-${{ steps.version.outputs.version }}-macos-x64.app.zip
        fail_on_unmatched_files: true
        
    - name: Send Telegram notification
      continue-on-error: true
      env:
        TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
        TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        COMMIT_MSG: ${{ steps.commit_message.outputs.message }}
        VERSION: ${{ steps.version.outputs.tag }}
        REPO: ${{ github.repository }}
      run: |
        npm install telegramify-markdown
        
        node <<EOF
        const https = require('https');
        
        // Async wrapper to allow using await and dynamic imports
        (async () => {
          // Dynamically import telegramify-markdown (it might be an ES module)
          const module = await import('telegramify-markdown');
          const telegramify = module.default || module;

          const commitMsg = process.env.COMMIT_MSG;
          const version = process.env.VERSION;
          const repo = process.env.REPO;
          const releaseUrl = \`https://github.com/\${repo}/releases/tag/\${version}\`;
          
          // Construct the full message in Standard Markdown
          const fullMarkdown = \`# üéâ PT Mate \${version} ÂèëÂ∏É‰∫ÜÔºÅ\n\n\${commitMsg}\n\nüì± [GitHub Release](\${releaseUrl})\`;
          
          // Convert to MarkdownV2
          const escapedMessage = telegramify(fullMarkdown);
          
          console.log('Processed Message:', escapedMessage);

          const payload = {
            chat_id: process.env.TG_CHAT_ID,
            text: escapedMessage,
            parse_mode: 'MarkdownV2',
            disable_web_page_preview: false
          };

          // Helper function to wait
          const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

          // Helper function to send requests
          function sendRequest(method, endpoint, data) {
            return new Promise((resolve, reject) => {
              const url = \`https://api.telegram.org/bot\${process.env.TG_BOT_TOKEN}/\${endpoint}\`;
              const req = https.request(url, {
                method: method,
                headers: { 'Content-Type': 'application/json' },
                timeout: 15000 // 15s timeout
              }, (res) => {
                let body = '';
                res.on('data', (chunk) => body += chunk);
                res.on('end', () => {
                  try {
                    const json = JSON.parse(body);
                    resolve(json);
                  } catch (e) {
                    reject(e);
                  }
                });
              });
              req.on('timeout', () => {
                req.destroy();
                reject(new Error('Request timed out after 15 seconds'));
              });
              req.on('error', reject);
              if (data) req.write(JSON.stringify(data));
              req.end();
            });
          }

          async function sendWithRetry(method, endpoint, data, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
              try {
                const res = await sendRequest(method, endpoint, data);
                if (res.ok) return res;
                // If not ok, might be rate limited or other API errors
                console.error(\`Telegram API error (Attempt \${i+1}):\`, JSON.stringify(res));
              } catch (err) {
                console.error(\`Network error (Attempt \${i+1}):\`, err.message);
              }
              if (i < maxRetries - 1) {
                const waitTime = 2000 * (i + 1);
                console.log(\`Retrying in \${waitTime}ms...\`);
                await delay(waitTime);
              }
            }
            throw new Error(\`Failed after \${maxRetries} attempts\`);
          }

          try {
            console.log('Sending message...');
            const sendRes = await sendWithRetry('POST', 'sendMessage', payload);
            
            const messageId = sendRes.result.message_id;
            console.log('Message sent successfully with ID:', messageId);
            
            // Unpin all messages
            await sendWithRetry('POST', 'unpinAllChatMessages', { chat_id: process.env.TG_CHAT_ID });
            
            // Pin the new message
            await sendWithRetry('POST', 'pinChatMessage', {
              chat_id: process.env.TG_CHAT_ID,
              message_id: messageId,
              disable_notification: false
            });
            
            console.log('Message pinned successfully');
          } catch (error) {
            console.error('Final Error:', error.message);
            process.exit(1);
          }
        })();
        EOF

    - name: Notify Update Server (POST /api/v1/github/version-update)
      env:
        UPDATE_SERVER_URL: ${{ vars.UPDATE_SERVER_URL }}
        GITHUB_WEBHOOK_SECRET: ${{ secrets.UPDATE_WEBHOOK_SECRET }}
        VERSION_TAG: ${{ steps.version.outputs.tag }}
        VERSION: ${{ steps.version.outputs.version }}
        RELEASE_NOTES: ${{ steps.commit_message.outputs.message }}
      run: |
        set -euo pipefail

        if [ -z "${UPDATE_SERVER_URL:-}" ]; then
          echo "UPDATE_SERVER_URL is not set. Skipping update server notification."
          exit 0
        fi

        DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/tag/${VERSION_TAG}"
        
        # Build JSON payload safely
        JSON_PAYLOAD=$(jq -n \
          --arg version "$VERSION" \
          --arg release_notes "$RELEASE_NOTES" \
          --arg download_url "$DOWNLOAD_URL" \
          '{
            version: $version,
            release_notes: $release_notes,
            download_url: $download_url
          }')

        echo "Sending version update to $UPDATE_SERVER_URL/api/v1/github/version-update"
        echo "$JSON_PAYLOAD" | curl -sS -X POST "$UPDATE_SERVER_URL/api/v1/github/version-update" \
          -H "Content-Type: application/json" \
          -H "X-Webhook-Secret: ${GITHUB_WEBHOOK_SECRET}" \
          -d @- | tee /tmp/update_server_response.json

        HTTP_OK=$(jq -r '.message? // empty' /tmp/update_server_response.json || true)
        if [ -z "$HTTP_OK" ]; then
          echo "üòí Update server did not return success message. Response:" >&2
          cat /tmp/update_server_response.json >&2
          exit 1
        else
          echo "‚úÖ Update server acknowledged: $HTTP_OK"
        fi